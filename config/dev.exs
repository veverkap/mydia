import Config

# Configure your database
config :mydia, Mydia.Repo,
  database: Path.expand("../mydia_dev.db", __DIR__),
  pool_size: 5,
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  # SQLite-specific optimizations
  timeout: 5000,
  journal_mode: :wal,
  # 64MB cache
  cache_size: -64000,
  temp_store: :memory,
  synchronous: :normal,
  foreign_keys: :on,
  busy_timeout: 5000

# For development, we disable any cache and enable
# debugging and code reloading.
#
# The watchers configuration can be used to run external
# watchers to your application. For example, we can use it
# to bundle .js and .css sources.
config :mydia, MydiaWeb.Endpoint,
  # Binding to all interfaces to allow access from Docker host
  http: [ip: {0, 0, 0, 0}, port: String.to_integer(System.get_env("PORT") || "4000")],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: "VlPUd2fbnWjh6Di+7SGc2SSXpNhI0hN766FFAlct65wU5ARyiGvK9r3TqSqKyu0K",
  watchers: [
    esbuild: {Esbuild, :install_and_run, [:mydia, ~w(--sourcemap=inline --watch)]},
    tailwind: {Tailwind, :install_and_run, [:mydia, ~w(--watch)]}
  ]

# ## SSL Support
#
# In order to use HTTPS in development, a self-signed
# certificate can be generated by running the following
# Mix task:
#
#     mix phx.gen.cert
#
# Run `mix help phx.gen.cert` for more information.
#
# The `http:` config above can be replaced with:
#
#     https: [
#       port: 4001,
#       cipher_suite: :strong,
#       keyfile: "priv/cert/selfsigned_key.pem",
#       certfile: "priv/cert/selfsigned.pem"
#     ],
#
# If desired, both `http:` and `https:` keys can be
# configured to run both http and https servers on
# different ports.

# Watch static and templates for browser reloading.
config :mydia, MydiaWeb.Endpoint,
  live_reload: [
    web_console_logger: true,
    patterns: [
      ~r"priv/static/(?!uploads/).*(js|css|png|jpeg|jpg|gif|svg)$",
      ~r"priv/gettext/.*(po)$",
      ~r"lib/mydia_web/(?:controllers|live|components|router)/?.*\.(ex|heex)$"
    ]
  ]

# Enable dev routes for dashboard and mailbox
config :mydia, dev_routes: true

# Configure logger based on environment variables
# Set MYDIA_DEBUG=true or LOG_LEVEL=debug for verbose logging
log_level =
  cond do
    System.get_env("MYDIA_DEBUG") == "true" -> :debug
    System.get_env("LOG_LEVEL") == "debug" -> :debug
    true -> :info
  end

config :logger, level: log_level

# Do not include metadata nor timestamps in development logs (but include them in debug mode)
log_format =
  if log_level == :debug do
    "$time $metadata[$level] $message\n"
  else
    "[$level] $message\n"
  end

config :logger, :default_formatter,
  format: log_format,
  metadata: [:category, :operation, :user_id, :request_id]

# Set a higher stacktrace during development. Avoid configuring such
# in production as building large stacktraces may be expensive.
config :phoenix, :stacktrace_depth, 20

# Initialize plugs at runtime for faster development compilation
config :phoenix, :plug_init_mode, :runtime

config :phoenix_live_view,
  # Include debug annotations and locations in rendered markup.
  # Changing this configuration will require mix clean and a full recompile.
  debug_heex_annotations: true,
  debug_attributes: true,
  # Enable helpful, but potentially expensive runtime checks
  enable_expensive_runtime_checks: true

# Guardian secret key for development (NOT for production!)
config :mydia, Mydia.Auth.Guardian,
  secret_key: "dev_secret_key_replace_in_production_with_secure_random_key"

# Guardian JWT configuration for development
# Override with GUARDIAN_SECRET_KEY environment variable if needed
guardian_secret = System.get_env("GUARDIAN_SECRET_KEY") || "dev-secret-key-change-in-production"

config :mydia, Mydia.Auth.Guardian,
  issuer: "mydia",
  secret_key: guardian_secret,
  ttl: {30, :days}

# Ueberauth OIDC configuration for development
# These are read from environment variables set in Docker
# Support both OIDC_ISSUER and OIDC_DISCOVERY_DOCUMENT_URI
oidc_issuer =
  System.get_env("OIDC_ISSUER") ||
    case System.get_env("OIDC_DISCOVERY_DOCUMENT_URI") do
      nil ->
        nil

      discovery_uri ->
        # Extract issuer from discovery document URI
        # e.g., "https://auth.example.com/.well-known/openid-configuration" -> "https://auth.example.com"
        discovery_uri
        |> String.replace(~r/\/\.well-known\/openid-configuration$/, "")
    end

oidc_client_id = System.get_env("OIDC_CLIENT_ID")
oidc_client_secret = System.get_env("OIDC_CLIENT_SECRET")

IO.puts("Loading OIDC config:")
IO.puts("  OIDC_ISSUER: #{inspect(oidc_issuer)}")
IO.puts("  OIDC_CLIENT_ID: #{inspect(oidc_client_id)}")
IO.puts("  OIDC_CLIENT_SECRET: #{inspect(oidc_client_secret)}")

if oidc_issuer && oidc_client_id && oidc_client_secret do
  IO.puts("Configuring Ueberauth with OIDC (ueberauth_oidcc style)...")

  # Configure oidcc library to allow HTTP for development
  config :oidcc, :http_cache_duration, 0
  config :oidcc, :provider_configuration_opts, %{request_opts: %{transport_opts: []}}

  # Step 1: Configure the OIDC issuer (required by ueberauth_oidcc)
  config :ueberauth_oidcc, :issuers, [
    %{name: :default_issuer, issuer: oidc_issuer}
  ]

  # Step 2: Configure Ueberauth provider with inline options
  config :ueberauth, Ueberauth,
    providers: [
      oidc:
        {Ueberauth.Strategy.Oidcc,
         [
           issuer: :default_issuer,
           client_id: oidc_client_id,
           client_secret: oidc_client_secret,
           scopes: ["openid", "profile", "email"],
           callback_path: "/auth/oidc/callback",
           userinfo: true,
           uid_field: "sub",
           # Use standard OAuth2 auth methods for maximum compatibility
           # These methods (RFC 6749) work with all OIDC providers without requiring
           # special client configuration (unlike client_secret_jwt or private_key_jwt)
           preferred_auth_methods: [:client_secret_post, :client_secret_basic],
           # Use standard OAuth2 response mode (universally supported)
           # Avoids JARM modes (query.jwt, form_post.jwt) which require explicit
           # provider configuration and are not needed for most use cases
           response_mode: "query"
         ]}
    ]

  IO.puts("Ueberauth OIDC configured successfully!")
  IO.puts("Issuer: #{oidc_issuer}")
  IO.puts("Client ID: #{oidc_client_id}")
else
  IO.puts("OIDC not configured - missing environment variables")
end
