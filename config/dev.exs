import Config

# Configure your database based on DATABASE_TYPE environment variable
# Use DATABASE_TYPE=postgres to use PostgreSQL, otherwise SQLite is used
database_type =
  case System.get_env("DATABASE_TYPE") do
    "postgres" -> :postgres
    "postgresql" -> :postgres
    _ -> :sqlite
  end

# Set database_type for runtime helpers (used by Mydia.DB and migrations)
config :mydia, :database_type, database_type

case database_type do
  :postgres ->
    config :mydia, Mydia.Repo,
      hostname: System.get_env("DATABASE_HOST") || "localhost",
      port: String.to_integer(System.get_env("DATABASE_PORT") || "5433"),
      database: System.get_env("DATABASE_NAME") || "mydia_dev",
      username: System.get_env("DATABASE_USER") || "postgres",
      password: System.get_env("DATABASE_PASSWORD") || "postgres",
      pool_size: 5,
      stacktrace: true,
      show_sensitive_data_on_connection_error: true,
      timeout: 60_000

  :sqlite ->
    config :mydia, Mydia.Repo,
      database: Path.expand("../mydia_dev.db", __DIR__),
      pool_size: 5,
      stacktrace: true,
      show_sensitive_data_on_connection_error: true,
      # SQLite-specific optimizations
      # Increased timeout to handle long-running library scans (60 seconds)
      timeout: 60_000,
      journal_mode: :wal,
      # 64MB cache
      cache_size: -64000,
      temp_store: :memory,
      synchronous: :normal,
      foreign_keys: :on,
      # Increased busy_timeout to handle concurrent writes during library scans
      busy_timeout: 30_000
end

# For development, we disable any cache and enable
# debugging and code reloading.
#
# The watchers configuration can be used to run external
# watchers to your application. For example, we can use it
# to bundle .js and .css sources.
config :mydia, MydiaWeb.Endpoint,
  # Binding to all interfaces to allow access from Docker host
  http: [ip: {0, 0, 0, 0}, port: String.to_integer(System.get_env("PORT") || "4000")],
  check_origin: false,
  code_reloader: true,
  debug_errors: true,
  secret_key_base: "VlPUd2fbnWjh6Di+7SGc2SSXpNhI0hN766FFAlct65wU5ARyiGvK9r3TqSqKyu0K",
  watchers: [
    esbuild: {Esbuild, :install_and_run, [:mydia, ~w(--sourcemap=inline --watch)]},
    tailwind: {Tailwind, :install_and_run, [:mydia, ~w(--watch)]}
  ]

# ## SSL Support
#
# In order to use HTTPS in development, a self-signed
# certificate can be generated by running the following
# Mix task:
#
#     mix phx.gen.cert
#
# Run `mix help phx.gen.cert` for more information.
#
# The `http:` config above can be replaced with:
#
#     https: [
#       port: 4001,
#       cipher_suite: :strong,
#       keyfile: "priv/cert/selfsigned_key.pem",
#       certfile: "priv/cert/selfsigned.pem"
#     ],
#
# If desired, both `http:` and `https:` keys can be
# configured to run both http and https servers on
# different ports.

# Watch static and templates for browser reloading.
config :mydia, MydiaWeb.Endpoint,
  live_reload: [
    web_console_logger: true,
    patterns: [
      ~r"priv/static/(?!uploads/).*(js|css|png|jpeg|jpg|gif|svg)$",
      ~r"priv/gettext/.*(po)$",
      ~r"lib/mydia_web/(?:controllers|live|components|router)/?.*\.(ex|heex)$"
    ]
  ]

# Enable dev routes for dashboard and mailbox
config :mydia, dev_routes: true

# Configure logger based on environment variables
# Set MYDIA_DEBUG=true or LOG_LEVEL=debug for verbose logging
log_level =
  cond do
    System.get_env("MYDIA_DEBUG") == "true" -> :debug
    System.get_env("LOG_LEVEL") == "debug" -> :debug
    true -> :info
  end

config :logger, level: log_level

# Do not include metadata nor timestamps in development logs (but include them in debug mode)
log_format =
  if log_level == :debug do
    "$time $metadata[$level] $message\n"
  else
    "[$level] $message\n"
  end

config :logger, :default_formatter,
  format: log_format,
  metadata: [
    :request_id,
    :category,
    :operation,
    :user_id,
    # Media and library metadata
    :media_item_id,
    :media_item_count,
    :media_type,
    :media_file_id,
    :library_path_id,
    :library_path,
    :library_type,
    :required_library_types,
    # Episode and season metadata
    :episode_id,
    :episode_number,
    :episode_count,
    :episode,
    :episodes,
    :parsed_episodes,
    :episode_season,
    :season_number,
    :season,
    :parsed_season,
    :season_pack_season,
    :current_episode,
    :current_season,
    :new_episode,
    :old_episode,
    :total_episodes,
    :missing_count,
    # Title and identification metadata
    :title,
    :series_title,
    :result_title,
    :local_title,
    :tmdb_id,
    :provider_id,
    :provider_type,
    # File and path metadata
    :path,
    :path1,
    :path2,
    :file,
    :file_id,
    :file_path,
    :file_paths,
    :filename,
    :new_path,
    :old_path,
    :dest,
    :source,
    :original,
    :directory,
    :recursive,
    :sample_paths,
    # Download and torrent metadata
    :download_id,
    :client,
    :client_id,
    :save_path,
    :torrent_id,
    :torrent_name,
    :confidence,
    # Counts and statistics
    :count,
    :file_count,
    :total_files,
    :files_found,
    :files_scanned,
    :new_files,
    :modified_files,
    :deleted_count,
    :completed_count,
    :failed_count,
    :items_processed,
    :shows_processed,
    :orphaned_files_fixed,
    :tv_orphans_fixed,
    # Search and matching metadata
    :query,
    :score,
    :match_score,
    :best_score,
    :breakdown,
    :total_results,
    :no_results,
    :searches_performed,
    :searches_for_show,
    :searches_this_season,
    :searches_so_far,
    :search_count,
    :max_searches_per_run,
    :max_searches_per_season,
    # Quality and technical metadata
    :resolution,
    :codec,
    :audio,
    :device,
    :device1,
    :device2,
    # Status and results
    :reason,
    :error,
    :errors,
    :success,
    :successful,
    :failed,
    :skipped,
    :found,
    :total,
    :exit_code,
    :output,
    # Time and progress metadata
    :duration_ms,
    :retention_days,
    :completed_at,
    :air_date,
    :position,
    :percentage,
    # Job and configuration metadata
    :args,
    :mode,
    :type,
    :id,
    :key,
    :value,
    :metadata,
    :delete_files,
    :year,
    :show,
    # Additional metadata keys
    :from,
    :to,
    :deleted_files,
    :episodes_count,
    :episodes_skipped,
    :missing_episodes,
    :missing_percentage,
    :parsed_episode,
    :parsed_info,
    :has_parsed_info,
    :has_media_file_id,
    :matches,
    :match_result_keys,
    :associations_updated,
    :available_libraries,
    :current_search_count,
    :searches_remaining,
    :seasons_remaining,
    :shows_remaining,
    :shows_skipped,
    :show_searches_used,
    :max_searches_per_show,
    :invalid_paths_removed,
    :untracked_matched,
    :total_count,
    :media_item,
    :type_mismatches_detected,
    :movies_in_series_libs,
    :tv_in_movies_libs
  ]

# Set a higher stacktrace during development. Avoid configuring such
# in production as building large stacktraces may be expensive.
config :phoenix, :stacktrace_depth, 20

# Initialize plugs at runtime for faster development compilation
config :phoenix, :plug_init_mode, :runtime

config :phoenix_live_view,
  # Include debug annotations and locations in rendered markup.
  # Changing this configuration will require mix clean and a full recompile.
  debug_heex_annotations: true,
  debug_attributes: true,
  # Enable helpful, but potentially expensive runtime checks
  enable_expensive_runtime_checks: true

# Guardian secret key for development (NOT for production!)
config :mydia, Mydia.Auth.Guardian,
  secret_key: "dev_secret_key_replace_in_production_with_secure_random_key"

# Guardian JWT configuration for development
# Override with GUARDIAN_SECRET_KEY environment variable if needed
guardian_secret = System.get_env("GUARDIAN_SECRET_KEY") || "dev-secret-key-change-in-production"

config :mydia, Mydia.Auth.Guardian,
  issuer: "mydia",
  secret_key: guardian_secret,
  ttl: {30, :days}

# Ueberauth OIDC configuration for development
# These are read from environment variables set in Docker
# Support both OIDC_ISSUER and OIDC_DISCOVERY_DOCUMENT_URI
oidc_issuer =
  System.get_env("OIDC_ISSUER") ||
    case System.get_env("OIDC_DISCOVERY_DOCUMENT_URI") do
      nil ->
        nil

      discovery_uri ->
        # Extract issuer from discovery document URI
        # e.g., "https://auth.example.com/.well-known/openid-configuration" -> "https://auth.example.com"
        discovery_uri
        |> String.replace(~r/\/\.well-known\/openid-configuration$/, "")
    end

oidc_client_id = System.get_env("OIDC_CLIENT_ID")
oidc_client_secret = System.get_env("OIDC_CLIENT_SECRET")

if oidc_issuer && oidc_client_id && oidc_client_secret do
  # Configure oidcc library to allow HTTP for development
  config :oidcc, :http_cache_duration, 0
  config :oidcc, :provider_configuration_opts, %{request_opts: %{transport_opts: []}}

  # Step 1: Configure the OIDC issuer (required by ueberauth_oidcc)
  config :ueberauth_oidcc, :issuers, [
    %{name: :default_issuer, issuer: oidc_issuer}
  ]

  # Step 2: Configure Ueberauth provider with inline options
  config :ueberauth, Ueberauth,
    providers: [
      oidc:
        {Ueberauth.Strategy.Oidcc,
         [
           issuer: :default_issuer,
           client_id: oidc_client_id,
           client_secret: oidc_client_secret,
           scopes: ["openid", "profile", "email"],
           callback_path: "/auth/oidc/callback",
           userinfo: true,
           uid_field: "sub",
           # Use standard OAuth2 auth methods for maximum compatibility
           # These methods (RFC 6749) work with all OIDC providers without requiring
           # special client configuration (unlike client_secret_jwt or private_key_jwt)
           preferred_auth_methods: [:client_secret_post, :client_secret_basic],
           # Use standard OAuth2 response mode (universally supported)
           # Avoids JARM modes (query.jwt, form_post.jwt) which require explicit
           # provider configuration and are not needed for most use cases
           response_mode: "query"
         ]}
    ]
end
